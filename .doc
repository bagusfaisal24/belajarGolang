# create channel <-- coccurency
  c := make(chan string)
  go count(c)
  msg := <- c
  fmt.Println(msg)

  func count(c chan string) {
    for i:=1; i <= 5; i++ {
      c <- "sheep"
      time.sleep(time.Millisecond * 500)
    } 
  } 

# go routine <-- coccurency
  main() {
    go count()
    countTwo()
  }

  func countTwo() {
    for {
      fmt.Println('fish')
    }
  }

  func count() {
    for {
      fmt.Println('sheep')
    }
  }

# infinity loop 
  for {
    if condition {
      break
    }
  }

# sleep 
  time.Sleep(milisecond)
# console input
  fmt.Scanln()
# wait <-- use to wait for all process async/coccurency to finish
  main () {
    var wg sync.waitGroup
    wg.add(1)
    go func() {
      count()
      wg.Done()
    }()
    wg.Wait()
  }

# select <-- execute channel coccurenly
  chan1....
  chan2...
  go ...
  go ...

  select {
    case msg1 := <- chan1:
      fmt.Println(msg1)
    case msg2 := <- chan2:
      fmt.Println(msg2)
  }
# pointer
  main() {
    data := 1
    fmt.Println(data) // 2

    dataSlice := []string{"naufal","witri"}
  }

  func updateData(data *int){
    *data = 2
    // if using struct u should use bracket, (*data).name = .....
  }

  func updateDataSlice (data []string) {
    data[0] = "dede"
    // we dont use pointer cause, slice &s ome other type are work differently. see variable-type.png
    // Go is pass by value, but when we use slice, it actualy make new value & refenc it value to real slices., so u dont have to use pointer to refenc it.
  }

  // NOTES
  // value type need pointer : int, float, string, bool, struct
  // reference type dont need pointer :  slices, map, channel, pointer, function
# Deklarasi
  all decklaration with no assing, will be filled with it's zero values. 